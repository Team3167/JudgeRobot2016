// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3167.JudgeRobot2016;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Talon;
import org.usfirst.frc3167.JudgeRobot2016.commands.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {

	private Joystick driveStick = new Joystick(0);
	  
	//Preferences prefs = Preferences.getInstance();

    private BallWheels ballWheels;

    private Talon leftMotorA;
    private Talon leftMotorB;

    private Talon rightMotorA;
    private Talon rightMotorB;
    
    private RobotDrive driveA;
    private RobotDrive driveB;

    private static final int leftStickUpDown = 2;// positive down
    private static final int leftStickLeftRight = 1;// positive right
    private static final int rightStickUpDown = 5;// positive down
    private static final int rightStickLeftRight = 4;// positive right
    //private static final int directionalPadUpDown = ;
    private static final int directionalPadLeftRight = 6;// On/off; positive right
    //private static final int buttonA = ;// On/off
    //private static final int buttonB = ;// On/off
    //private static final int buttonX = ;// On/off
    //private static final int buttonY = ;// On/off
    //private static final int topTrigger = ;// On/off
    private static final int bottomTrigger = 3;// On/off; positive left

    private static final double turnRateScale = 0.8;
    
    //public static OI oi;

	/**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
    RobotMap.init();
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
       // oi = new OI();
    
    ballWheels = new BallWheels(4, 5);

    leftMotorA = new Talon(0);
    leftMotorB = new Talon(1);

    rightMotorA = new Talon(2);
    rightMotorB = new Talon(3);

    driveA = new RobotDrive(leftMotorA, rightMotorA);
    driveB = new RobotDrive(leftMotorB, rightMotorB);

	//prefs.putDouble("Kp", 1.0);
	//prefs.putDouble("Ki", 0.0);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    public void disabledInit(){

    }

    public void disabledPeriodic() {
        identifyControllerButtons();
    }

    public void autonomousInit() {
    }

    /**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() {
    	DoCommonUpdates();
    }

    public void teleopInit() {
    }

    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
    	DoCommonUpdates();
    	
    	if(driveStick.getRawButton(5))// Suck ball in
        {
            ballWheels.pullIn();
        }
        else if(driveStick.getRawButton(3))// Shoot ball out
        {
            ballWheels.shootOut();
        }
        else
        {
        	ballWheels.stop();
        }
    	
    	driveA.arcadeDrive(-driveStick.getRawAxis(leftStickUpDown),
                -driveStick.getRawAxis(leftStickLeftRight) * turnRateScale);
        driveB.arcadeDrive(-driveStick.getRawAxis(leftStickUpDown),
                -driveStick.getRawAxis(leftStickLeftRight) * turnRateScale);
    }
    
    private void updateSmartDashboard()
    {
    	//SmartDashboard.putNumber("Front Right Wheel Angle", drive.GetWheel(1).GetWheelAngle());
    	//SmartDashboard.putNumber("Rear Left Wheel Angle", drive.GetWheel(2).GetWheelAngle());
    	//SmartDashboard.putNumber("Rear Right Wheel Angle", drive.GetWheel(3).GetWheelAngle());
    	
    	//SmartDashboard.putNumber("Left Front Wheel KP", drive.GetWheel(0).getKP());
    	//SmartDashboard.putNumber("Left Front Wheel KI", drive.GetWheel(0).getKI()); 
    	//SmartDashboard.putNumber("Left Front Wheel KD", drive.GetWheel(0).getKD()); 
    	//SmartDashboard.putNumber("testSig", testSig); 
    	
    	//SmartDashboard.putNumber("Left Front Wheel speed", drive.GetWheel(0).GetWheelVelocity());
    	//SmartDashboard.putNumber("Left Front Wheel command speed", drive.GetWheel(0).getCANMotor().get() / drive.GetWheel(0).getGearRatio() * Conversions.RPMToRadPerSec);
    }
    
    private void DoCommonUpdates()
    {
    	updateSmartDashboard();
    	
    	// CAN objects - this line sends the commands
    	//CANJaguar.updateSyncGroup(RobotConfiguration.wheelCANSyncGroup);
    }
    
    private void identifyControllerButtons()
    {
        int i;
        for (i = 0; i < 12; i++)
        {
            if (driveStick.getRawAxis(i) > 0.5)
                System.out.println("Axis " + i + " -> Positive");
            else if (driveStick.getRawAxis(i) < -0.5)
                System.out.println("Axis " + i + " -> Negative");
            
            if (driveStick.getRawButton(i))
            	System.out.println("Button " + i);
        }
    }

    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() {
        LiveWindow.run();
    }
}
